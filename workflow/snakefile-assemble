import glob
import os.path

input_files=glob.glob("input/*.long_reads.fastq.gz")
#print(input_files)
DATASETS=[]
print("Running on the following datasets...")
for this_input_file in input_files:
    this_base_name=os.path.basename(this_input_file)
    #print(this_base_name)
    res = re.findall("(.+).long_reads.fastq.gz", this_base_name)
    if not res: continue
    print("  ", res[0])
    DATASETS.append(res[0])

num_resampled_read_sets=24
FLYE_RESAMPLED_IDS = ["01", "07", "13", "19"]
RAVEN_RESAMPLED_IDS = ["03", "09", "15", "21"]
MINIASM_MINIPOLISH_RESAMPLED_IDS = ["02", "08", "14", "20"]
ALL_RESAMPLED_IDS = FLYE_RESAMPLED_IDS + RAVEN_RESAMPLED_IDS + MINIASM_MINIPOLISH_RESAMPLED_IDS

rule all:
  input:
    expand("04_assemblies/{dataset}/assembly_{assembly_id}.fasta", dataset=DATASETS, assembly_id=ALL_RESAMPLED_IDS)

rule assemble_with_flye:
    input:
        "02_subsampled_long_reads/{dataset}/sample_{assembly_id}.fastq"
    wildcard_constraints:
        assembly_id="|".join(FLYE_RESAMPLED_IDS),
    output:
        "04_assemblies/{dataset}/assembly_{assembly_id}.fasta"
    conda:
        "envs/flye.yml"
    threads: 16
    shell:
        "mkdir -p 03_assembly_intermediates/{wildcards.dataset}/assembly_{wildcards.assembly_id} && flye --nano-raw {input} --threads {threads} --out-dir 03_assembly_intermediates/{wildcards.dataset}/assembly_{wildcards.assembly_id} && cp 03_assembly_intermediates/{wildcards.dataset}/assembly_{wildcards.assembly_id}/assembly.fasta {output} && cp 03_assembly_intermediates/{wildcards.dataset}/assembly_{wildcards.assembly_id}/assembly_graph.gfa 03_assembly_intermediates/{wildcards.dataset}/assembly_{wildcards.assembly_id}_01.gfa"


rule assemble_with_miniasm_minipolish:
    input:
        "02_subsampled_long_reads/{dataset}/sample_{assembly_id}.fastq"
    wildcard_constraints:
        assembly_id="|".join(MINIASM_MINIPOLISH_RESAMPLED_IDS),
    output:
        assembly = "04_assemblies/{dataset}/assembly_{assembly_id}.fasta",
        graph = "04_assemblies/{dataset}/assembly_{assembly_id}..gfa"
    conda:
        "envs/miniasm_minipolish.yml"
    threads: 16
    shell:
        """
        # Create temporary intermediate files.
        overlaps=$(mktemp)".paf"
        unpolished_assembly=$(mktemp)".gfa"

        # Find read overlaps with minimap2.
        minimap2 -x ava-ont -t {threads} {input} {input} > "$overlaps" 
        #2>> {log}

        # Run miniasm to make an unpolished assembly.
        miniasm -f {input} "$overlaps" > "$unpolished_assembly" 
        #2>> {log}

        # Polish the assembly with minipolish, outputting the result to stdout.
        minipolish --threads {threads} {input} "$unpolished_assembly" > {output.graph} 
        #2>> {log}

        # Convert to fasta
        any2fasta {output.graph} > {output.assembly}
        # 2>> {log}
        
        # Clean up.
        rm "$overlaps" "$unpolished_assembly"
        """

rule assemble_with_raven:
    input:
        "02_subsampled_long_reads/{dataset}/sample_{assembly_id}.fastq"
    wildcard_constraints:
        assembly_id="|".join(RAVEN_RESAMPLED_IDS),
    output:
        "04_assemblies/{dataset}/assembly_{assembly_id}.fasta"
    conda:
        "envs/raven.yml"
    threads: 16
    shell:
        "raven --threads {threads} --disable-checkpoints --graphical-fragment-assembly 04_assemblies/{wildcards.dataset}/assembly_{wildcards.assembly_id}.gfa {input} > {output}"

